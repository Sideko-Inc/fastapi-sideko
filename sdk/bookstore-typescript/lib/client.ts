// Generated by Sideko (sideko.dev)
import * as fs from "fs";
import axios, {
	AxiosResponse,
	AxiosInstance,
	ResponseType,
	AxiosRequestConfig,
} from "axios";
import { stringify as QsStringify } from "qs";

import { RequestError, UnexpectedStatusError } from "./error";
import {
	Author,
	NotFound,
	ValidationError,
	Book,
	HttpValidationError,
	GenreEnum,
} from "./schemas";
import { GetBookRequest } from "./request_types";

export default class Client {
	public instance: AxiosInstance;
	private auth: Record<
		string,
		((axCfg: AxiosRequestConfig) => AxiosRequestConfig) | undefined
	>;

	constructor(config?: {
		apiKey?: string | null;
		baseUrl?: string;
		timeout?: number;
	}) {
		this.instance = axios.create({
			baseURL: config?.baseUrl ?? "http://127.0.0.1:8000",
			timeout: config?.timeout ?? 1000,
		});
		// register auth providers
		this.auth = {};
		this.auth["api_key"] = (axCfg: AxiosRequestConfig) => {
			if (config?.apiKey) {
				axCfg = {
					...axCfg,
					headers: { ...(axCfg.headers ?? {}), "x-api-key": config.apiKey },
				};
			}
			return axCfg;
		};
	}

	authedAxiosConfig(
		authNames: string[],
		axiosConfig: AxiosRequestConfig,
	): AxiosRequestConfig {
		for (const authName of authNames) {
			const provider = this.auth[authName];
			if (provider) {
				axiosConfig = provider(axiosConfig);
			}
		}

		return axiosConfig;
	}

	/**
	 */
	public async listBooks(): Promise<Book[]> {
		const url = `/books`;
		const method = "GET";

		const axiosConfig = {
			validateStatus: () => true,
			method,
			url,
			params: {},
			paramsSerializer: function (params) {
				return QsStringify(params, { arrayFormat: "comma" });
			},
			headers: {},
		};

		const authedConfig = this.authedAxiosConfig(["api_key"], axiosConfig);

		const response = await this.instance.request(authedConfig);

		const responseHandlers = [
			{
				isMatch: (status: number): boolean => status === 200,
				matches: "200",
				handle: (res: AxiosResponse): Book[] => {
					return res.data as Book[];
				},
				isError: false,
			},
		];

		const handler = responseHandlers.find((h) => h.isMatch(response.status));
		if (!handler) {
			throw new UnexpectedStatusError({
				response,
				method,
				url,
				expectedStatuses: responseHandlers.map((h) => h.matches),
			});
		}

		const responseData = handler.handle(response);

		if (handler.isError) {
			throw new RequestError({ response, method, url });
		}

		return responseData as Book[];
	}

	/**
	 */
	public async getBook(request: GetBookRequest): Promise<Book> {
		const url = `/books/${request.id}`;
		const method = "GET";

		const axiosConfig = {
			validateStatus: () => true,
			method,
			url,
			params: {},
			paramsSerializer: function (params) {
				return QsStringify(params, { arrayFormat: "comma" });
			},
			headers: {},
		};

		const authedConfig = this.authedAxiosConfig(["api_key"], axiosConfig);

		const response = await this.instance.request(authedConfig);

		const responseHandlers = [
			{
				isMatch: (status: number): boolean => status === 200,
				matches: "200",
				handle: (res: AxiosResponse): Book => {
					return res.data as Book;
				},
				isError: false,
			},
			{
				isMatch: (status: number): boolean => status === 404,
				matches: "404",
				handle: (res: AxiosResponse): NotFound => {
					return res.data as NotFound;
				},
				isError: true,
			},
			{
				isMatch: (status: number): boolean => status === 422,
				matches: "422",
				handle: (res: AxiosResponse): HttpValidationError => {
					return res.data as HttpValidationError;
				},
				isError: true,
			},
		];

		const handler = responseHandlers.find((h) => h.isMatch(response.status));
		if (!handler) {
			throw new UnexpectedStatusError({
				response,
				method,
				url,
				expectedStatuses: responseHandlers.map((h) => h.matches),
			});
		}

		const responseData = handler.handle(response);

		if (handler.isError) {
			throw new RequestError({ response, method, url });
		}

		return responseData as Book;
	}
}
